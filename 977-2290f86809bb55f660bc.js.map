{"version":3,"file":"977-2290f86809bb55f660bc.js","mappings":"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","sources":["webpack://personal-site/./node_modules/smoothscroll-anchor-polyfill/dist/index.mjs"],"sourcesContent":["/** @license MIT smoothscroll-anchor-polyfill@1.3.4 (c) 2021 Jonas Kuske */\n// @ts-check\n\n/**\n * @typedef {Object} GlobalFlag\n * @prop {boolean} [__forceSmoothscrollAnchorPolyfill__]\n * **DEPRECATED**: use `polyfill({ force: boolean })`\n *\n * @typedef {typeof globalThis & Window & GlobalFlag} WindowWithFlag\n */\n\n/***/\nvar isBrowser = typeof window !== 'undefined';\nvar w = isBrowser &&\n/** @type {WindowWithFlag} */\nwindow;\nvar d = isBrowser && document;\nvar docEl = isBrowser && d.documentElement;\nvar mockEl = isBrowser && d.createElement('a');\n\nvar hasNativeSupport = function hasNativeSupport() {\n  return isBrowser && 'scrollBehavior' in mockEl;\n};\n/**\n * @param {HTMLElement} el\n * @returns {el is HTMLAnchorElement}\n */\n\n\nvar isAnchor = function isAnchor(el) {\n  return /^a$/i.test(el.tagName);\n};\n/**\n * Check if an element is an anchor pointing to a target on the current page\n * @param {HTMLAnchorElement} anchor\n */\n\n\nvar targetsLocalElement = function targetsLocalElement(anchor) {\n  // False if element isn't \"a\" or href has no #fragment\n  if (!/#/.test(anchor.href)) return false; // Fix bug in IE9 where anchor.pathname misses leading slash\n\n  var pathname =\n  /** @type {HTMLAnchorElement} */\n  anchor.pathname;\n  if (pathname[0] !== '/') pathname = '/' + pathname; // False if target isn't current page\n\n  if (anchor.hostname !== location.hostname || pathname !== location.pathname) return false; // False if anchor targets a ?query that is different from the current one\n  // e.g. /?page=1 ‚Üí /?page=2#content\n\n  if (anchor.search && anchor.search !== location.search) return false;\n  return true;\n};\n/**\n * @param {HTMLElement} el\n * @returns {?HTMLAnchorElement} The found element or null\n */\n\n\nvar getAnchor = function getAnchor(el) {\n  if (isAnchor(el) && targetsLocalElement(el)) return el;\n  return el.parentElement ? getAnchor(el.parentElement) : null;\n};\n/**\n * Returns the element whose id matches the hash or\n * document.body if the hash is \"#top\" or \"\" (empty string)\n * @param {string} hash\n */\n\n\nvar getScrollTarget = function getScrollTarget(hash) {\n  if (typeof hash !== 'string') return null;\n\n  try {\n    hash = decodeURIComponent(hash); // \"#%F0%9F%91%8D%F0%9F%8F%BB\" -> \"#üëçüèª\"\n  } catch (_unused) {} // Retrieve target if an id is specified in the hash, otherwise use body.\n  // If hash is \"#top\" and no target with id \"top\" was found, also use body\n  // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#attr-href\n\n\n  var target = hash ? d.getElementById(hash.slice(1)) : d.body;\n  if (hash === '#top' && !target) target = d.body;\n  return target;\n};\n/**\n * Focuses an element, if it's not focused after the first try,\n * allow focusing by adjusting tabIndex and retry\n * @param {HTMLElement} el\n */\n\n\nvar focusElement = function focusElement(el) {\n  var focusOptions = {\n    preventScroll: true\n  };\n  el.focus(focusOptions);\n\n  if (d.activeElement !== el) {\n    var prevTabIndex = el.getAttribute('tabindex');\n    el.setAttribute('tabindex', '-1');\n\n    if (getComputedStyle(el).outlineStyle === 'none') {\n      var prevOutline = el.style.outlineStyle;\n      el.style.outlineStyle = 'none';\n      el.addEventListener('blur', function undoOutlineChange() {\n        el.style.outlineStyle = prevOutline || '';\n        prevTabIndex != null ? el.setAttribute('tabindex', prevTabIndex) : el.removeAttribute('tabindex');\n        el.removeEventListener('blur', undoOutlineChange);\n      });\n    }\n\n    el.focus(focusOptions);\n  }\n}; // Stores the setTimeout id of pending focus changes, allows aborting them\n\n\nvar pendingFocusChange; // Check if browser supports focus without automatic scrolling (preventScroll)\n\nvar supportsPreventScroll = false;\n\nif (isBrowser) {\n  try {\n    // Define getter for preventScroll to find out if the browser accesses it\n    var preppedFocusOption = Object.defineProperty({}, 'preventScroll', {\n      // eslint-disable-next-line getter-return\n      get: function get() {\n        supportsPreventScroll = true;\n      }\n    }); // Trigger focus ‚Äì if browser uses preventScroll the const will be set to true\n\n    mockEl.focus(preppedFocusOption);\n  } catch (_unused2) {}\n}\n/**\n * Scrolls to a given element or to the top if the given element\n * is document.body, then focuses the element\n * @param {HTMLElement} target\n */\n\n\nvar triggerSmoothscroll = function triggerSmoothscroll(target) {\n  // Clear potential pending focus change triggered by a previous scroll\n  if (!supportsPreventScroll) clearTimeout(pendingFocusChange); // Use JS scroll APIs to scroll to top (if target is body) or to the element\n  // This allows polyfills for these APIs to do their smooth scrolling magic\n\n  var scrollTop = target === d.body;\n  if (scrollTop) w.scroll({\n    top: 0,\n    left: 0,\n    behavior: 'smooth'\n  });else target.scrollIntoView({\n    behavior: 'smooth',\n    block: 'start'\n  }); // If the browser supports preventScroll: immediately focus the target\n  // Otherwise schedule the focus so the smoothscroll isn't interrupted\n\n  if (supportsPreventScroll) focusElement(target);else pendingFocusChange = setTimeout(focusElement.bind(null, target), 450);\n};\n/**\n * Returns true if scroll-behavior: smooth is set and not overwritten\n * by a higher-specifity declaration, else returns false\n */\n\n\nvar shouldSmoothscroll = function shouldSmoothscroll() {\n  // Regex to extract the value following the scroll-behavior property name\n  var extractValue = /scroll-behavior:[\\s]*([^;\"']+)/;\n  var docElStyle = getComputedStyle(docEl); // Values to check for set scroll-behavior in order of priority/specificity\n\n  var valuesToCheck = [// Priority 1: behavior assigned to style property\n  // Allows toggling smoothscroll from JS (docEl.style.scrollBehavior = ...)\n  docEl.style.scrollBehavior, // Priority 2: behavior specified inline in style attribute\n  (extractValue.exec(docEl.getAttribute('style')) || [])[1], // Priority 3: custom property\n  // Behaves like regular CSS, e.g. allows using media queries\n  docElStyle.getPropertyValue('--scroll-behavior'), // Priority 4: behavior specified in fontFamily\n  // Same use case as priority 3, but supports legacy browsers without CSS vars\n  (extractValue.exec(docElStyle.fontFamily) || [])[1]]; // Loop over values in specified order, return once a valid value is found\n\n  for (var i = 0; i < valuesToCheck.length; i++) {\n    var value = valuesToCheck[i] && valuesToCheck[i].trim();\n    if (/^smooth$/.test(value)) return true;\n    if (/^(initial|inherit|auto|unset)$/.test(value)) return false;\n  } // No value found? Return false, no set value = no smoothscroll :(\n\n\n  return false;\n}; // @ts-check\n\n\nvar defaultExport = {\n  polyfill: polyfill,\n  destroy: destroy\n};\n/**\r\n * Starts the polyfill by attaching the neccessary EventListeners\r\n *\r\n * Bails out if scrollBehavior is natively supported and the force flag\r\n * isn't set on the options argument or globally on window\r\n * @param {PolyfillOptions} [opts] Options for invoking the polyfill\r\n *\r\n * @typedef {Object} PolyfillOptions\r\n * @prop {boolean} [force] Enable despite native support, overrides global flag\r\n */\n\nfunction polyfill() {\n  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  destroy(); // Remove previous listeners\n\n  if (isBrowser) {\n    var globalFlag = w.__forceSmoothscrollAnchorPolyfill__;\n    var force = typeof opts.force === 'boolean' ? opts.force : globalFlag; // Abort if smoothscroll has native support and force flag isn't set\n\n    if (hasNativeSupport() && !force) return;\n    d.addEventListener('click', handleClick, false);\n    d.addEventListener('scroll', trackScrollPositions);\n    w.addEventListener('hashchange', handleHashChange);\n  }\n\n  return defaultExport;\n}\n/** Stops the polyfill by removing all EventListeners */\n\n\nfunction destroy() {\n  if (isBrowser) {\n    d.removeEventListener('click', handleClick, false);\n    d.removeEventListener('scroll', trackScrollPositions);\n    w.removeEventListener('hashchange', handleHashChange);\n  }\n\n  return defaultExport;\n}\n/**\r\n * Checks if the clicked target is an anchor pointing to a local element.\r\n * If so, prevents default behavior and handles the scroll using the\r\n * native JavaScript scroll APIs so smoothscroll-polyfill applies\r\n * @param {MouseEvent} evt\r\n */\n\n\nfunction handleClick(evt) {\n  var notPrimaryClick = evt.metaKey || evt.ctrlKey || evt.shiftKey || evt.button !== 0;\n  if (evt.defaultPrevented || notPrimaryClick) return; // scroll-behavior not set to smooth? Bail out, let browser handle it\n\n  if (!shouldSmoothscroll()) return; // Check the DOM from the click target upwards if a local anchor was clicked\n\n  var anchor = getAnchor(\n  /** @type {HTMLElement} */\n  evt.target);\n  if (!anchor) return; // Find the element targeted by the hash\n\n  var target = getScrollTarget(anchor.hash);\n\n  if (target) {\n    // Prevent default browser behavior to avoid a jump to the anchor target\n    evt.preventDefault(); // Trigger the smooth scroll\n\n    triggerSmoothscroll(target); // Append the hash to the URL\n\n    if (history.pushState) history.pushState(null, d.title, anchor.href);\n  }\n} // To enable smooth scrolling on hashchange, we need to immediately restore\n// the scroll pos after a hashchange changed it, so we track it constantly.\n// Some browsers don't trigger a scroll event before the hashchange,\n// so to undo, the position from last scroll is the one we need to go back to.\n// In others (e.g. IE) the scroll listener is triggered again before the\n// hashchange occurs and the last reported position is already the new one\n// updated by the hashchange ‚Äì we need the second last to undo there.\n// Because of this we don't track just the last, but the last two positions.\n\n\nvar lastTwoScrollPos = [];\n/** Returns the scroll offset towards the top */\n\nvar getScrollTop = function getScrollTop() {\n  return docEl.scrollTop || d.body.scrollTop;\n};\n/**\r\n * Tries to undo the automatic, instant scroll caused by a hashchange\r\n * and instead scrolls smoothly to the new hash target\r\n */\n\n\nfunction handleHashChange() {\n  // scroll-behavior not set to smooth or body not parsed yet? Abort\n  if (!d.body || !shouldSmoothscroll()) return;\n  var target = getScrollTarget(location.hash);\n  if (!target) return; // If the position last reported by the scroll listener is the same as the\n  // current one caused by a hashchange, go back to second last ‚Äì else last\n\n  var currentPos = getScrollTop();\n  var top = lastTwoScrollPos[lastTwoScrollPos[1] === currentPos ? 0 : 1]; // @ts-ignore\n  // Undo the scroll caused by the hashchange...\n  // Using {behavior: 'instant'} even though it's not in the spec anymore as\n  // Blink & Gecko support it ‚Äì once an engine with native support doesn't,\n  // we need to disable scroll-behavior during scroll reset, then restore\n\n  w.scroll({\n    top: top,\n    behavior: 'instant'\n  }); // ...and instead smoothscroll to the target\n\n  triggerSmoothscroll(target);\n}\n/** Update the last two scroll positions */\n\n\nfunction trackScrollPositions() {\n  if (!d.body) return; // Body not parsed yet? Abort\n\n  lastTwoScrollPos[0] = lastTwoScrollPos[1];\n  lastTwoScrollPos[1] = getScrollTop();\n}\n\npolyfill();\nexport { defaultExport as default, destroy, polyfill };"],"names":["pendingFocusChange","isBrowser","window","w","d","document","docEl","documentElement","mockEl","createElement","hasNativeSupport","getAnchor","el","test","tagName","isAnchor","anchor","href","pathname","hostname","location","search","targetsLocalElement","parentElement","getScrollTarget","hash","decodeURIComponent","_unused","target","getElementById","slice","body","focusElement","focusOptions","preventScroll","focus","activeElement","prevTabIndex","getAttribute","setAttribute","getComputedStyle","outlineStyle","prevOutline","style","addEventListener","undoOutlineChange","removeAttribute","removeEventListener","supportsPreventScroll","preppedFocusOption","Object","defineProperty","get","_unused2","triggerSmoothscroll","clearTimeout","scroll","top","left","behavior","scrollIntoView","block","setTimeout","bind","shouldSmoothscroll","extractValue","docElStyle","valuesToCheck","scrollBehavior","exec","getPropertyValue","fontFamily","i","length","value","trim","defaultExport","polyfill","destroy","opts","arguments","undefined","globalFlag","__forceSmoothscrollAnchorPolyfill__","force","handleClick","trackScrollPositions","handleHashChange","evt","notPrimaryClick","metaKey","ctrlKey","shiftKey","button","defaultPrevented","preventDefault","history","pushState","title","lastTwoScrollPos","getScrollTop","scrollTop","currentPos"],"sourceRoot":""}